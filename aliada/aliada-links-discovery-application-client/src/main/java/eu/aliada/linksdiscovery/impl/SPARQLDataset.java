// ALIADA - Automatic publication under Linked Data paradigm
//          of library and museum data
//
// Component: aliada-links-discovery-application-client
// Responsible: ALIADA Consortium
package eu.aliada.linksdiscovery.impl;

import java.util.ArrayList;
import java.util.Iterator;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import org.xml.sax.SAXException;


import de.fuberlin.wiwiss.silk.Silk;
import eu.aliada.linksdiscovery.model.JobConfiguration;
import eu.aliada.linksdiscovery.model.SubjobConfiguration;
import eu.aliada.shared.log.Log;
import eu.aliada.linksdiscovery.log.MessageCatalog;
import eu.aliada.shared.rdfstore.RDFStoreDAO;

/**
 * Links discovery process which uses SILK library for discovering links. 
 * 
 * @author Idoia Murua
 * @since 2.0
 */
public class SPARQLDataset {
	/** For logging. */
	private static final Log LOGGER  = new Log(SPARQLDataset.class);
	/** XML configuration file for SILK. */
	private File linkingXMLConfigFile;
	/** Names of the files containing the links */
	private ArrayList<String> triplesFilenames;


	/**
	 * Obtain triples generated output files names from XML config file,
	 * generated by SILK.
	 *
	 * @return	triples generated output files names from XML config file,
	 * 			generated by SILK.
	 * @since 1.0
	 */
	public ArrayList<String> getTriplesFilenames(){
		//Obtain triples generated output files names from XML config file 
		triplesFilenames = new ArrayList<String>();
		try {
			//Read XML file
			final DocumentBuilderFactory dbFactory = DocumentBuilderFactory.newInstance();
			final DocumentBuilder dBuilder = dbFactory.newDocumentBuilder();
			final Document doc = dBuilder.parse(linkingXMLConfigFile);		 
			doc.getDocumentElement().normalize();
	
			//Get <Output> nodes
			final NodeList outputList = doc.getElementsByTagName("Output");
			for (int outputInd = 0; outputInd < outputList.getLength(); outputInd++) {
				final Node outputNode = outputList.item(outputInd);
				if (outputNode.getNodeType() == Node.ELEMENT_NODE) {
					final Element outputElem = (Element) outputNode;
					final String typeValue = outputElem.getAttribute("type");
					//Check if <Output type="file"> 
					if("file".equalsIgnoreCase(typeValue)){
						//Get <Param> nodes
						final NodeList paramList = outputElem.getElementsByTagName("Param");
						for (int paramInd = 0; paramInd < paramList.getLength(); paramInd++) {
							final Node paramNode = paramList.item(paramInd);
							if (paramNode.getNodeType() == Node.ELEMENT_NODE) {
								final Element paramElem = (Element) paramNode;
								final String nameValue = paramElem.getAttribute("name");
								//Check if <Param name="file" ...>
								if("file".equalsIgnoreCase(nameValue)){
									//Get the name of the file
									triplesFilenames.add(paramElem.getAttribute("value"));
								}
							}
						}
					}

				}
			}
	
		} catch (ParserConfigurationException exception) {
			LOGGER.error(MessageCatalog._00062_XML_FILE_PARSING_FAILURE, exception, linkingXMLConfigFile);
		} catch (SAXException exception) {
			LOGGER.error(MessageCatalog._00062_XML_FILE_PARSING_FAILURE, exception, linkingXMLConfigFile);
		} catch (IOException exception) {
			LOGGER.error(MessageCatalog._00062_XML_FILE_PARSING_FAILURE, exception, linkingXMLConfigFile);
		}
		
		return triplesFilenames;
	}

	/**
	 * Gets the number of links generated by SILK.
	 * This number is obtained by counting the number of triples generated 
	 * in the SILK outputs files.
	 *
	 * @return	the number of links generated by SILK.
	 * @since 1.0
	 */
	public int getNumLinks(){
		int numLinks = 0;
		/** Names of the files containing the links */
		getTriplesFilenames();
		for (final Iterator<String> iter = triplesFilenames.iterator(); iter.hasNext();  ) {
			final String triplesFilename = iter.next();
			try{
				final BufferedReader bufferReader = new BufferedReader(new FileReader(triplesFilename));
				while (bufferReader.readLine() != null) {
				   numLinks++;
				}
				LOGGER.info(MessageCatalog._00061_NUM_GENERATED_LINKS, numLinks);
				bufferReader.close();
			} catch(FileNotFoundException exception) {
				LOGGER.error(MessageCatalog._00031_FILE_NOT_FOUND, triplesFilename);
		   	} catch(IOException exception) {
				LOGGER.error(MessageCatalog._00032_BAD_FILE, exception, triplesFilename);
		    }
		}
		return numLinks;
	}


	/**
	 * It performs the search with SILK and inserts the discovered links in the appropriate graph.
	 *
	 * @param jobConf		the {@link eu.aliada.linksdiscovery.model.JobConfiguration}
	 *						that contains global information for configuring the linking processes.  
	 * @param subjobConf 	the {@link eu.aliada.linksdiscovery.model.SubjobConfiguration}
	 *						which contains the configuration of the subjob.
	 * @return 
	 * @since 2.0
	 */
	public int searchProcess (JobConfiguration jobConf, SubjobConfiguration subjobConf) {
		int numLinks = 0; 
		//Verify that the XML configuration file for SILK really exists
		try{
			linkingXMLConfigFile = new File(subjobConf.getLinkingXMLConfigFilename());
			if (!linkingXMLConfigFile.exists()){
				linkingXMLConfigFile = null;
				LOGGER.error(MessageCatalog._00031_FILE_NOT_FOUND, subjobConf.getLinkingXMLConfigFilename());
			}
		}catch (Exception exception) {
			linkingXMLConfigFile = null;
			LOGGER.error(MessageCatalog._00031_FILE_NOT_FOUND, exception, subjobConf.getLinkingXMLConfigFilename());
		}
		if(linkingXMLConfigFile != null) {
			LOGGER.info(MessageCatalog._00053_SILK_STARTING, linkingXMLConfigFile, subjobConf.getLinkingNumThreads(), subjobConf.isLinkingReloadSource(), subjobConf.isLinkingReloadTarget());
			try {
				Silk.executeFile(linkingXMLConfigFile, (String) null, subjobConf.getLinkingNumThreads(), subjobConf.isLinkingReloadSource(), subjobConf.isLinkingReloadTarget());
			} catch (Exception exception){
				LOGGER.error(MessageCatalog._00054_SILK_EXCEPTION, exception);
			}
			LOGGER.info(MessageCatalog._00055_SILK_FINISHED, linkingXMLConfigFile, subjobConf.getLinkingNumThreads(), subjobConf.isLinkingReloadSource(), subjobConf.isLinkingReloadTarget());
			//Check the number of generated links
			LOGGER.debug(MessageCatalog._00060_VALIDATING_NUM_GENERATED_LINKS, linkingXMLConfigFile);
			numLinks = getNumLinks();
			//Upload generated links to RDF store
			final RDFStoreDAO rdfstoreDAO = new RDFStoreDAO();
			LOGGER.debug(MessageCatalog._00068_UPLOADING_GENERATED_LINKS);
			for (final Iterator<String> iter = triplesFilenames.iterator(); iter.hasNext();  ) {
				final String triplesFilename = iter.next();
				if(!rdfstoreDAO.loadDataIntoGraphBySparql(triplesFilename, jobConf.getOutputURI(), jobConf.getOutputLogin(), jobConf.getOutputPassword(), jobConf.getOutputGraph())) {
					LOGGER.error(MessageCatalog._00069_TRIPLES_FILE_UPLOAD_ERROR, triplesFilename);
				}
				//Remove triples file
				try {
					File triplesFile = new File(triplesFilename);
					if (triplesFile.exists()) {
						triplesFile.delete();
					}
				} catch (Exception exception) {
					LOGGER.error(MessageCatalog._00066_FILE_REMOVING_FAILURE, exception, triplesFilename);
				}
			}
		}
		return numLinks;
	}

}
